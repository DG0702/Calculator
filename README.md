#  📑 Calculator

📗 **계산기 프로젝트**

- **이번 과제의 목표 : 자바 문법 실습과 객체 지향 개념의 적용**

## 🖥️ 개발 프로세스(환경)

### ⛏️IDE :
- `Intellij`

### 📌 Java :
- **JDK 17버전 사용**

### 🔁 Version Control :
- `GitHub`

<br>
<hr>

## ✅ 프로젝트 가이드

### LV 1️⃣ : 클래스 없이 기본적인 연산을 수행 할 수 있는 계산기 만들기

#### 🍭 양의 정수 (0포함)를 입력 받기

- **양의 정수는 각각 하나씩 전달 받습니다.**

#### 🍭 사칙 연산 기호 입력 받기

- **사칙 연산 기호를 `charAt(0)` 타입으로 표현**

#### 🍭 입력 받은 값과 사칙 연산 기호로 연산 진행 후 결과값 출력

- **사칙연산 기호에 맞는 연산자를 사용하여 연산을 진행합니다.**


- **제어문을 사용해서 처리합니다. (`if`, `switch`)**


- **연산 오류 발생시 오류에 대한 내용을 정제하여 출력합니다**
  - **ex) 나눗셈 연산에서 분모(두번째 정수)에 0이 입력될 수 없습니다.**

#### 🍭 반복문을 사용하되, 반복의 종료를 알려주는 "exit" 문자열을 입력하기 전까지 무한으로 계산

- ❗ **반복문 사용 -> `exit` 입력 시 반복 종료**

<br>
<hr>

### LV 2️⃣ : 클래스를 적용해 기본적인 연산을 수행할 수 있는 계산기 만들기

#### 🍭 LV 1에서 기능 추가 -> 기존 기능이 사용 가능해야합니다

#### 🍭 Calculator 클래스 생성

- **사칙 연산을 수행 후 결과값을 반환하는 `메서드` 구현**
  - **양의 정수(0포함) 2개와 연산 기호를 매개 변수로 받아 사칙연산 기능을 수행**


- **연산 결과 값을 저장하는 컬렉션 `필드`를 생성**

#### 🍭 Lv1에서 구현한 App 클래스의 main 메서드에 Calculator 클래스 활용

- **연산 수행 역할 -> Calculator 클래스 담당**


- **연산 결과는 Calculator 클래스의 연산 결과를 저장하는 컬렉션 필드에 저장**

#### 🍭 App 클래스의 main 메서드에서 Calculator 클래스의 컬렉션 필드에 직접 접근 불가 (캡슐화)

- **간접 접근을 통해 필드에 접근하여 가져올 수 있도록 구현 (Getter 메서드)**


- **간접 접근을 통해 필드에 접근하여 수정할 수 있도록 구현 (Setter 메서드)**


- **main 메서드에서 setter, getter 메서드 활용할 수 있도록 구현**

#### 🍭 연산 결과를 저장하는 컬렉션 필드에서 가장 먼저 저장된 데이터를 삭제하는 메서드 구현

- **main 메서드에서 삭제 메서드(removeResult)가 활용할 수 있도록 구현**

<br>
<hr>

### LV 3️⃣ : Enum, 제네릭, 람다 & 스트림을 이해한 계산기 만들기

#### 🍭 Enum 타입을 활용하여 연산자 타입에 대한 정보를 관리하고 계산기 클래스(ArithmeticCalculator)에 활용

#### 🍭 입력 받는 값을 정수가 아닌 실수도 가능하도록 만들기

- **ArithmeticCalculator 클래스의 사칙 연산 계산기 메서드 (calculator)**
- **단순히 int 타입, double 타입으로 바꾸는 것이 아닌 제네릭을 활용**

#### 🍭 저장된 연산 결과들 중 Scanner로 입력받는 값보다 큰 결과값 들을 출력

- **조회 메서드 생성 -> 입력값보다 큰 결과값들을 출력하는 메서드**
  - **단 Lambda & Stream 활용**

<br>
<hr>

## 💠 진행 과정

### 1. Git 연결 -> 원격 Repository 생성

### 2. Intellij 로컬 Repository -> project 생성 후 -> Git 연결

### 3. test 파일 생성 후 연결 확인

### 4. 프로젝트 진행

<br>
<hr>

## ✨ 트러블 슈팅

### 진행 과정

- **원격 Repository <-> 로컬 Repository 연결 시 README 파일이 존재할 경우**


- **강제 병합 코드: `git pull origin main --allow unrelated-histories` 사용**


- **Repository를 서로 독립적으로 만들었기 때문에 문제 발생**

<br>

### LV 1️⃣

- **문제 : 숫자 외에 값을 입력 받았을 경우 오류 발생**


- **해결 : try-catch문을 이용하여 예외처리하여 재입력하도록 유도**

<br>

### LV 2️⃣

- **문제 : 요구사항 파악을 제대로 하지 못해 기능을 잘못 구현함**
  - **setter,getter 구현 후 main 메서드에서 활용하지 않음**
  - **컬렉션 필드 생성과 관련된 메서드를 구현하지 않음**


- **해결 : 여러 번 요구사항을 읽으면서 요구사항 기능을 구현하고 활용**
  - **setter, getter main 메서드에서 활용**
  - **컬렉션 필드 생성 후 저장된 값을 확인하는 메서드, 값을 제거하는 메서드 활용**

<br>

### LV 3️⃣

#### 문제 :

- **OperatorType 열거형 클래스에서 Enum 타입을 사용해야하는데 enum의 개념 부족**


- **상수에 할당된 값을 못 가지고옴**


- **계산을 처리하는 ArithmeticCalculator 클래스에서 제네릭 사용**


- **OperatorType 클래스의 상수 이용 개념 부족**


- **계산 후 결과값 표현할 때 데이터 타입 오류**


- **입력값보다 큰 값 반환하는 메서드에서 논리연산자 개념 부족**


- **입력값 타입 문제 -> 실수로 타입 설정시 입력값을 정수로 받아도 실수로 표현**


- **calculate() 메서드 매개변수 타입 맞지 않아 오류 발생**


- **calculate() 메서드에 연산 과정 타입 맞지 않은 발견 (입력값마다 다르게 설정 필요)**


- **showResult() 메서드 NullPointerException 오류 발생**

<br>

#### 해결 :

- **google 서칭 , chatgpt 개념 확인 , 튜터님에게 질문**


- **toString() 메서드를 재정의하여 상수의 할당된 값을 가지고 옴**


- **제네릭 사용이 익숙하지 않았지만 강의 내용을 다시 찾아보고 chatgpt로 타입제한을 개념을 파악**


- **열거형 클래스는 정적 클래스로 클래스에서 직접 접근하여 사용 가능하지만 -> 메서드에서 매개변수로 받아서 사용**


- **제네릭 타입은 사칙연산이 불가능하기 때문에 정수,실수 타입으로 변경하여 사용**


- **||, && 의 개념을 헷갈려했지만 반대로 사용해보고 의미를 파악함**



- **입력 받는 값을 String 타입을 받은 후 -> 다른 변수에 담아서 (Double,Integer)타입을 변환**


- **매개변수도 String 값으로 받고 -> OperatorType 타입으로 변경 -> 입력값을 커스텀하는 getOperatorType() 생성**


- **instanceof를 사용하여 타입 조건을 나누어서 연산과정을 수정**


- **showResult() 메서드에 값이 없어서 발생 -> setter을 이용해 해결 (매개변수를 받아서 해결할 수도 있음)**

<br>

#### 배운점 :

- **enum은 열거형 클래스**


- **enum의 정의 : 상수들의 집합**
  - **(상수 : 변하지 않는 값, final 키워드로 정의된 변수)**
  - **할당된 값을 활용**
  - **ex) EARTH("지구") -> EARTH : 상수, "지구" : 할당된 값**


- **제네릭 타입의 제한으로 타입 변경이 가능한 부분을 배움**


- **실행할 때 타입 변환에 대해서 더 깊게 생각해야하는구나를 느낌**

<br>
<hr>

## ❗ 기존코드 작성, 트러블 슈팅 -> 피드백으로 변경사항 발생 

<br>
<hr>

## 🌟 튜터님 피드백

### LV 1️⃣

- **코드 들여쓰기**


- **중복된 코드 통합(System.out.println())**

<br>


### LV 2️⃣

- **코드 들여쓰기**


- **중복된 코드 통합(System.out.println())**


- **값이 중첩 될 수 있는 부분 수정**
  - **(setter 설정 후 메서드에서 매개변수 받을 경우 멀티쓰레드에서 값이 덮힐 수 있음)**
  - **요구사항에 setter, getter 활용이 있었지만 코드 호율이 안 좋을거 같아 수정 -> 다시 활용하도록 수정 가능**


- **주요 메서드 사용 위치**
  - **반복문 안보다는 밖에서 구현했을 때 성능이 좋음**  

<br>


### LV 3️⃣

- **OperatorType 열거형 클래스에서 할당된 값 메서드 중복되는걸 확인 -> 수정**
  - **toString(), getOperator() 같은 의미로 사용되어 toString() 삭제**  


- **calculator() : 사칙연산을 하는 메서드 -> 정수, 실수 부분을 따로 나눔**
  - **intCalculate() , doubleCalculate() 로 나눔**


- **LV2와 마찬가지로 setter, getter 사용을 하지 않음**
   - **매개변수를 이용하여 값을 받고 setter getter 사용을 줄임 -> 주석 처리 -> 다시 활용 가능**
   - **매개변수로 Integer , Double 타입으로 활용**


- **showResult() : 조회 메서드 의 매개변수로 값을 받을 수 있도록 수정** 


- **숫자를 입력받고 정수 실수를 나누는 부분에 코드가 중첩이 있어 수정 시도**
  - **제네릭을 Number로 받아서 결국 중복 코드가 발생한다는 시행착오를 껶음**
    - **입력값이 String 타입이기 때문에 메서드에서 분류 후 -> 다시 타입 변환으르 해야하는 문제 발생**
    - **정수 실수 2타입을 만족하기 위해 Number 타입으로 메서드 구헌 -> 반환값 Number 타입**
    - **결국 사용하기 위해 다시 타입 변환해야하는 상황 발생**


- **클래스 분류를 해야겠다는 생각은 들었지만 시간이 없어 일단 한 클래스에서 구현 할 수 있도록 설계**
  - **최대한 유지보수와 가독성을 높이려고 해봄**


- **enum에 대해 다시 한 번 알아봄 -> enum에 사용 이유에 대해 조금 알게됨 -> 계속 사용해야 알거 같음..**


<br>
<hr>

## ❗ 피드백 후 느낌점

#### 코드 완성 후 계속해서 리팩토링을 수행하여 코드를 수정하는 것에 중요성을 느낌

#### 나 혼자 사용하는 것이 아니라 유지보수와 가독성을 생각하면서 코드를 리팩토링 해봐야겠다고 생각함
